{"version":3,"sources":["webpack:///do_external_connect.min.js","webpack:///webpack/bootstrap e43fd23b1c63bfea3afe?a67b*","webpack:///./react/features/base/config/parseURLParams.js?0f67*","webpack:///./react/features/base/config/getRoomName.js?918e*","webpack:///./connection_optimization/do_external_connect.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","148","__webpack_exports__","parseURLParams","url","dontParse","arguments","length","source","paramStr","search","hash","params","substr","split","forEach","part","param","key","JSON","parse","decodeURIComponent","replace","e","msg","String","console","warn","window","onerror","a","233","getRoomName","getroomnode","config","path","location","pathname","substring","lastIndexOf","toLowerCase","974","checkForConnectHandlerAndConnect","APP","connect","status","handler","errorCallback","error","XMPPAttachInfo","__WEBPACK_IMPORTED_MODULE_0__react_features_base_config_getRoomName__","__WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__","createConnectionExternally","externalConnectUrl","roomName","token","jwt","connectionInfo","data"],"mappings":"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","file":"do_external_connect.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/libs/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 974);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 148:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = parseURLParams;\n\n\n/**\n * Parses the parameters from the URL and returns them as a JS object.\n *\n * @param {string} url - The URL to parse.\n * @param {boolean} dontParse - If false or undefined some transformations\n * (for parsing the value as JSON) are going to be executed.\n * @param {string} source - Values - \"hash\"/\"search\" if \"search\" the parameters\n * will parsed from location.search otherwise from location.hash.\n * @returns {Object}\n */\nfunction parseURLParams(url) {\n    var dontParse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hash';\n\n    var paramStr = source === 'search' ? url.search : url.hash;\n    var params = {};\n\n    // eslint-disable-next-line newline-per-chained-call\n    paramStr && paramStr.substr(1).split('&').forEach(function (part) {\n        var param = part.split('=');\n        var key = param[0];\n\n        if (!key) {\n            return;\n        }\n\n        var value = void 0;\n\n        try {\n            value = param[1];\n            if (!dontParse) {\n                value = JSON.parse(decodeURIComponent(value).replace(/\\\\&/, '&'));\n            }\n        } catch (e) {\n            var msg = 'Failed to parse URL parameter value: ' + String(value);\n\n            console.warn(msg, e);\n            window.onerror && window.onerror(msg, null, null, null, e);\n\n            return;\n        }\n        params[key] = value;\n    });\n\n    return params;\n}\n\n/***/ }),\n\n/***/ 233:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getRoomName;\n\n\n/**\n * Builds and returns the room name.\n *\n * @returns {string}\n */\nfunction getRoomName() {\n    var getroomnode = config.getroomnode;\n\n    var path = window.location.pathname;\n    var roomName = void 0;\n\n    // Determine the room node from the URL.\n    if (getroomnode && typeof getroomnode === 'function') {\n        roomName = getroomnode.call(config, path);\n    } else {\n        // Fall back to the default strategy of making assumptions about how the\n        // URL maps to the room (name). It currently assumes a deployment in\n        // which the last non-directory component of the path (name) is the\n        // room.\n        roomName = path.substring(path.lastIndexOf('/') + 1).toLowerCase() || undefined;\n    }\n\n    return roomName;\n}\n\n/***/ }),\n\n/***/ 974:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__react_features_base_config_getRoomName__ = __webpack_require__(233);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__ = __webpack_require__(148);\n/* global config, createConnectionExternally */\n\n\n\n\n/**\n * Implements external connect using createConnectionExternally function defined\n * in external_connect.js for Jitsi Meet. Parses the room name and JSON Web\n * Token (JWT) from the URL and executes createConnectionExternally.\n *\n * NOTE: If you are using lib-jitsi-meet without Jitsi Meet, you should use this\n * file as reference only because the implementation is Jitsi Meet-specific.\n *\n * NOTE: For optimal results this file should be included right after\n * external_connect.js.\n */\n\nif (typeof createConnectionExternally === 'function') {\n    // URL params have higher proirity than config params.\n    var url = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__[\"a\" /* default */])(window.location, true, 'hash')['config.externalConnectUrl'] || config.externalConnectUrl;\n    var roomName = void 0;\n\n    if (url && (roomName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__react_features_base_config_getRoomName__[\"a\" /* default */])())) {\n        url += '?room=' + roomName;\n\n        var token = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__[\"a\" /* default */])(window.location, true, 'search').jwt;\n\n        if (token) {\n            url += '&token=' + token;\n        }\n\n        createConnectionExternally(url, function (connectionInfo) {\n            // Sets that global variable to be used later by connect method\n            // in connection.js.\n            window.XMPPAttachInfo = {\n                status: 'success',\n                data: connectionInfo\n            };\n            checkForConnectHandlerAndConnect();\n        }, errorCallback);\n    } else {\n        errorCallback();\n    }\n} else {\n    errorCallback();\n}\n\n/**\n * Check if connect from connection.js was executed and executes the handler\n * that is going to finish the connect work.\n *\n * @returns {void}\n */\nfunction checkForConnectHandlerAndConnect() {\n    window.APP && window.APP.connect.status === 'ready' && window.APP.connect.handler();\n}\n\n/**\n * Implements a callback to be invoked if anything goes wrong.\n *\n * @param {Error} error - The specifics of what went wrong.\n * @returns {void}\n */\nfunction errorCallback(error) {\n    // The value of error is undefined if external connect is disabled.\n    error && console.warn(error);\n\n    // Sets that global variable to be used later by connect method in\n    // connection.js.\n    window.XMPPAttachInfo = {\n        status: 'error'\n    };\n    checkForConnectHandlerAndConnect();\n}\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// do_external_connect.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/libs/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 974);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e43fd23b1c63bfea3afe","/* @flow */\n\n/**\n * Parses the parameters from the URL and returns them as a JS object.\n *\n * @param {string} url - The URL to parse.\n * @param {boolean} dontParse - If false or undefined some transformations\n * (for parsing the value as JSON) are going to be executed.\n * @param {string} source - Values - \"hash\"/\"search\" if \"search\" the parameters\n * will parsed from location.search otherwise from location.hash.\n * @returns {Object}\n */\nexport default function parseURLParams(\n        url: URL,\n        dontParse: boolean = false,\n        source: string = 'hash'): Object {\n    const paramStr = source === 'search' ? url.search : url.hash;\n    const params = {};\n\n    // eslint-disable-next-line newline-per-chained-call\n    paramStr && paramStr.substr(1).split('&').forEach(part => {\n        const param = part.split('=');\n        const key = param[0];\n\n        if (!key) {\n            return;\n        }\n\n        let value;\n\n        try {\n            value = param[1];\n            if (!dontParse) {\n                value\n                    = JSON.parse(decodeURIComponent(value).replace(/\\\\&/, '&'));\n            }\n        } catch (e) {\n            const msg = `Failed to parse URL parameter value: ${String(value)}`;\n\n            console.warn(msg, e);\n            window.onerror && window.onerror(msg, null, null, null, e);\n\n            return;\n        }\n        params[key] = value;\n    });\n\n    return params;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./react/features/base/config/parseURLParams.js","/* @flow */\n\ndeclare var config: Object;\n\n/**\n * Builds and returns the room name.\n *\n * @returns {string}\n */\nexport default function getRoomName(): ?string {\n    const { getroomnode } = config;\n    const path = window.location.pathname;\n    let roomName;\n\n    // Determine the room node from the URL.\n    if (getroomnode && typeof getroomnode === 'function') {\n        roomName = getroomnode.call(config, path);\n    } else {\n        // Fall back to the default strategy of making assumptions about how the\n        // URL maps to the room (name). It currently assumes a deployment in\n        // which the last non-directory component of the path (name) is the\n        // room.\n        roomName\n            = path.substring(path.lastIndexOf('/') + 1).toLowerCase()\n                || undefined;\n    }\n\n    return roomName;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./react/features/base/config/getRoomName.js","/* global config, createConnectionExternally */\n\nimport getRoomName from '../react/features/base/config/getRoomName';\nimport parseURLParams from '../react/features/base/config/parseURLParams';\n\n/**\n * Implements external connect using createConnectionExternally function defined\n * in external_connect.js for Jitsi Meet. Parses the room name and JSON Web\n * Token (JWT) from the URL and executes createConnectionExternally.\n *\n * NOTE: If you are using lib-jitsi-meet without Jitsi Meet, you should use this\n * file as reference only because the implementation is Jitsi Meet-specific.\n *\n * NOTE: For optimal results this file should be included right after\n * external_connect.js.\n */\n\nif (typeof createConnectionExternally === 'function') {\n    // URL params have higher proirity than config params.\n    let url\n        = parseURLParams(window.location, true, 'hash')[\n                'config.externalConnectUrl']\n            || config.externalConnectUrl;\n    let roomName;\n\n    if (url && (roomName = getRoomName())) {\n        url += `?room=${roomName}`;\n\n        const token = parseURLParams(window.location, true, 'search').jwt;\n\n        if (token) {\n            url += `&token=${token}`;\n        }\n\n        createConnectionExternally(\n            url,\n            connectionInfo => {\n                // Sets that global variable to be used later by connect method\n                // in connection.js.\n                window.XMPPAttachInfo = {\n                    status: 'success',\n                    data: connectionInfo\n                };\n                checkForConnectHandlerAndConnect();\n            },\n            errorCallback);\n    } else {\n        errorCallback();\n    }\n} else {\n    errorCallback();\n}\n\n/**\n * Check if connect from connection.js was executed and executes the handler\n * that is going to finish the connect work.\n *\n * @returns {void}\n */\nfunction checkForConnectHandlerAndConnect() {\n    window.APP\n        && window.APP.connect.status === 'ready'\n        && window.APP.connect.handler();\n}\n\n/**\n * Implements a callback to be invoked if anything goes wrong.\n *\n * @param {Error} error - The specifics of what went wrong.\n * @returns {void}\n */\nfunction errorCallback(error) {\n    // The value of error is undefined if external connect is disabled.\n    error && console.warn(error);\n\n    // Sets that global variable to be used later by connect method in\n    // connection.js.\n    window.XMPPAttachInfo = {\n        status: 'error'\n    };\n    checkForConnectHandlerAndConnect();\n}\n\n\n\n// WEBPACK FOOTER //\n// ./connection_optimization/do_external_connect.js"],"sourceRoot":""}